* * *
# 201744020 박지석
* * *
## Multi Thread를 이용한 채팅 프로그램
* * *
### 1. 개요
 네트워크 프로그래밍 분야에서 소켓 프로그래밍은 연결된 네트워크의 양 끝단을 추상화시킨 개념이며, </br>
 컴퓨터의 관점에서는네트워크로 통하는 컴퓨터의 외부와 컴퓨터 내부의 프로그램을 이어주는 인터페이스이다.</br>
 소켓 프로그래밍 중 하나인 멀티 프로세스 방식을 이용하여 파이썬을 기반으로 리눅스 환경에서 채팅 프로그램을 </br>
 구현하고자 하였다. 또한 CLI 환경에서 채팅프로그램을 구동하기엔 사용자 편의성 측면으로 제한성이 있기 때문에 </br>
 파이썬 내의 GUI 인터페이스인 'tkinter'을 이용하여 GUI 또한 구현하고자 하였다.
 
 ### 2. 목적
  요즘같은 정보화시대에서 사람과 사람 사이의 정보를 주고 받을 수 있는 채팅 프로그램은 없어서는 안될 필수 요소가 되었다.
  대표적인 예로 카카오톡, 인스타그램 다이렉트 메세지가 있다. 이러한 프로그램들에게서 영감을 받아 기본적인 채팅 기능을 구현 및 배포가 주 목적이다.
  
 ### 3. 설계 및 기능
  채팅 프로그램은 멀티 쓰레드 방식을 이용하여 여러 사람이 실시간으로 채팅할 수 있도록 구현하였다.<br>
  **<서버 코드 분석>**<br>
 <img width="" height="" src="./이미지/서버_코드_1.PNG"></img>
  <br>
  <br>
  ● **class ChattingRoom**<br><br>
  => '__init__' 메서드는 이것이 바로 파이썬에서 약속된 메서드 가운데 하나로 초기화(initialize) 메서드이다. 어떤 클래스의 객체가 만들어질 때 
  자동으로 호출되어서 그 객체가 갖게 될 여러 가지 성질을 정해주는 일을 한다. self.list란 클라이언트의 정보를 담을 리스트이다.<br><br>
  => addUser(self,client) 메서드에서는 클라이언트에서 입력한 정보를 받아와 self.list에 클라이언트(사용자)를 추가한다.<br>
  클라이언트가 추가될 때마다 채팅방에 있는 모든 클라이언트(사용자)들에게 채팅방 룰과 현재 채팅방 인원수에 대한 정보를 제공한다.<br><br>
  => deleteUser(self,client) 메서드에서는 클라이언트가 채팅방에서 퇴장을 했을 경우 self.list에서 클라이언트에 대한 정보를 모두 삭제한다.<br><br>
  => sendAll(self,msg) 메서드에서는 클라이언트가 채팅방에서 작성한 메세지를 리스트에 존재하는 모든 클라이언트(사용자)들에게 모두 뿌려주는 메서드이다.<br><br>
   ● **class ChatClient**<br><br>
   => 'init' 메서드에서 클라이언트의 닉네임 정보, 소켓 정보를 선언받는다.<br><br>
   => recvMessage 메서드에서는 recv 함수를 이용하여 클라이언트 소켓을 거친 최대 크기가 1024인 메세지 정보를 받아 decoding 작업을 우선적으로 진행한다. 만약 클라이언트(사용자)가 보낸 메세지 정보가 '/quit'라면 ChatClient 클래스 안의 sendMessage 메서드를 통해 현재 채팅방 사용자들에게 메세지를 보낸 후 서버와 클라이언트들에게 '/quit' 메세지를 보낸 클라이언트가 퇴장되었다는 알림을 보여준다. '/quit'가 아니라면 클라이언트의 닉네임과 함께 메세지를 함께 채팅방 내의 클라이언트(사용자)들에게 출력해 보여준다.<br><br>
   => sendMessage 메서드에서는 클라이언트의 메세지 정보를 받아 encode 작업을 진행 후 모든 사용자들에게 보내는 작업을 한다.<br><br>
   => run 메서드에서는 파이썬에서 쓰레드를 실행하기 위해서 threading 모듈의 Thread() 함수를 호출하여 Thread 객체를 얻은 후 Thread  객체의 start() 메서드를 호출한다.<br><br>
 <img width="" height="" src="./이미지/서버_코드_2.PNG"></img>
 <br>
 <br>
  ● **class RunServer**<br><br>
  => ServerOpen 메서드에서 IPv4 체계, TCP 타입 소켓 객체를 생성하고, setsockopt 함수는 포트를 사용 중 일때 에러를 해결하기 위해 선언해준다. 이후 bind 함수를 통해 ip주소와 port 번호를 함께 socket에 바인드하고, listen 함수는 서버가 클라이언트의 접속을 얼마나 허용할 것인지에 대해 선언한다.<br><br>
  => run 메서드에서는 채팅 서버 시작 메세지와 종료를 위한 단축키 정보를 제공하며, accept 함수에서 대기하다가 클라이언트가 접속하면 새로운 소켓을 리턴한다. 이후 클라이언트(사용자)가 채팅에 사용할 닉네임을 받기 위해 닉네임 정보 입력 요청 메세지를 접속한 클라이언트에게 전송한다.<br>
  이후 클라이언트의 닉네임 정보와 소켓 정보를 받아 ChattingRoom 클래스의 addUser 메서드로 정보를 반환해주어 self.list에 클라이언트를 추가한다. 

  **<클라이언트 코드 분석>**<br>
  <img width="" height="" src="./이미지/클라이언트_코드_1.PNG"></img>
  <br>
  <br>
  => 우선 ip 와 port를 전역 변수로 선언해준다. <br>
  => sendMessage 메서드에서는 사용자들에게 보낼 메세지를 입력해주고 인코딩 작업을 거친 후 사용자들에게 메세지를 전달한다. 메세지 입력 전에 사용자들이 서버에 접속하게 되면 서버에서 제공하는 채팅방 룰과 채팅방을 나가기 위한 키워드 정보를 제공 받은 뒤 채팅을 시작하게 된다. 만약 사용자가 '/quit' 키워드를 입력하게 된다면 종료를 원한다는 메세지와 함께 퇴장 메세지를 출력해주면서 채팅방을 퇴장하게 된다. <br><br>
  => recvMessage 메서드에서는 다른 사용자들이 보낸 메세지 정보를 recv 함수로 정보를 받아 decode 함수를 거쳐 읽을 수 있도록 해준다.<br><br>
  ● **class Client**<br><br>
  => 'init' 함수로 우선 클라이언트 소캣 정보를 초기화 해준다. 이후 socket 메서드에서 서버와 연결을 위한 IPv4 체계와 TCP 타입 소켓 객체를 생성하고, 이후 ip와 port 번호를 통해 연결한다.
  
 ### 4. 실행 결과 화면
  <img width="" height="" src="./이미지/실행결과.PNG"></img><br>
  <img width="" height="" src="./이미지/실행결과_1.PNG"></img><br><br>
  
  ### 5. 구현할 때 어려웠던 점
   우선 구현하는데 오랜 기간 시간을 투자했음에도 불구하고 독자적으로 프로그램을 구현하는데에 큰 한계를 느끼게 되었고, 결국 초기에 구상했던 기능들과 GUI를 구현하지 못하였다. 특히 GUI는 파이썬 내의 GUI 인터페이스인 'tkinter'를 이용하여 구현할 예정이었는데, tkinter 구현 코드와 함께 프로그램을 구동하게 되면 'Tkinter tclError couldn't connect to display :0.0'라는 오류가 발생하며 tkinter 인터페이스를 호출하지 못하였다.
   이를 해결하기 위해 tkinter, xort-server, xinit, xlaunch 를 재설치 후 홈 디렉토리에서 '.bash_profile'에서 'export DISPLAY=:0.0' 구문을 다시 추가후 다시 구동을 해 보았지만 오류는 여전하였다. 이에 인터넷에 오류 명을 검색해보고 듀얼 모니터에서 싱글 모니터로 바꿔보기도 하고 
   실행 컴퓨터를 변경하여 프로그램을 구동해보았지만 작동하지 않았고, 결국 해결 방안을 찾지 못한 채 GUI 구현을 하지 못하였다.<br>
   본래는 강의 교안에 있는 GUI_ChatServer 의 코드를 응용하여 프로젝트 구현을 하려 했으나, GUI 문제를 해결하지 못하여 코드를 사용하지 못하였고, 다른 기본 베이스 코드를 사용하였다. 시간을 많이 투자한것에 비해 본인의 능력 한계로 인해 기능 추가를 하지 못하고, 채팅 프로그램의 기본 베이스 코드 분석을 위주로 보고서를 작성하게 되었다.
 
